top, voici un **prompt prêt à coller dans Cursor** pour te générer un starter complet (Web) : **React + Vite + TypeScript + Phaser 3 + Tailwind**, orienté “jeu interactif pour faire lire la Bible (tradition orthodoxe) aux enfants”.

---

## Prompt Cursor (copie-colle tout)

**RÔLE**
Tu es un *staff engineer* chargé de livrer un starter propre, accessible et prêt à publier sur le web et mobile (PWA). Priorité à la lisibilité du code, l’accessibilité, et une structure claire pour ajouter des “leçons” bibliques sous forme de JSON.

**OBJECTIF**
Créer un projet **React + Vite + TypeScript** avec **Phaser 3** pour les mini-jeux. Le thème est un jeu éducatif pour enfants 6–12 ans, afin d’aimer la lecture de la Bible dans la tradition chrétienne orthodoxe (respectueux du sacré).

**FONCTIONNALITÉS À LIVRER DÈS LE STARTER**

1. **Accueil React** avec :

   * Titre du jeu, bouton “Commencer”, bouton “Réglages” (police, taille du texte, audio on/off, contraste).
   * Menu “Chemins” : *Ancien Testament*, *Vie du Christ*, *Fêtes*.
   * Carte “Jonas et le grand poisson” (exemple fourni) → lance une scène Phaser “OrderEvents”.
2. **Phaser intégré** via un composant `<PhaserGame />` propre (montage/démontage sans fuite mémoire).
3. **Contenu JSON** (exemple `content/jonas_01.json`) avec lecture guidée, vocabulaire, quiz, verset clé.
4. **Mini-jeu 1 (Phaser)** : **Remettre les scènes dans l’ordre** (4 cartes). Détecte victoire et renvoie un callback à React pour afficher un écran “Bravo + Badge”.
5. **Journal** (localStorage) : enregistre la progression (terminé/à refaire, badges obtenus). Bouton “Exporter en PDF/print” (version simple print-CSS).
6. **Accessibilité** :

   * Taille de police réglable (+/−), *OpenDyslexic* optionnelle.
   * Contraste élevé (toggle), sous-titres, narration on/off (stubs).
   * Navigation clavier (focus ring visible), aria-labels.
7. **Respect & contenu** :

   * Aucune gamification sur objets sacrés. Récompenses non compétitives (badges “Ami des Prophètes”, “Disciple des Paraboles”…).
   * Placeholder pour textes bibliques (ne pas embarquer de texte protégé).
8. **PWA** : manifest + service worker vite-plugin-pwa (offline de base).
9. **Qualité** : ESLint + Prettier + strict TS + scripts NPM.

**TECH & LIBS**

* Vite, React, TypeScript.
* Phaser 3 (2D).
* Tailwind CSS.
* Zustand (état global léger) pour réglages & progression.
* vite-plugin-pwa.
* ESLint, Prettier.
* Option: `@fontsource/opendyslexic` (ou charger localement).

**ARBORESCENCE ATTENDUE**

```
/src
  /components
    PhaserGame.tsx
    Menu.tsx
    SettingsDialog.tsx
    LessonCard.tsx
    Journal.tsx
  /phaser
    mainGame.ts
    scenes/OrderEventsScene.ts
    types.d.ts
  /content
    jonas_01.json
  /state
    settingsStore.ts
    progressStore.ts
  /pages
    Home.tsx
    Lesson.tsx
  /styles
    index.css
  app.tsx
  main.tsx
/assets
  /images (placeholders: bg.jpg, jonas_1.png..jonas_4.png)
/public
  icon-192.png, icon-512.png, manifest.webmanifest
.eslintrc.cjs
.prettierrc
tailwind.config.js
vite.config.ts
index.html
```

**EXEMPLES DE FICHIERS (génère-les intégralement)**

1. `src/content/jonas_01.json`

```json
{
  "id": "jonas_01",
  "title": "Jonas et le grand poisson",
  "path": "Ancien Testament",
  "reading": [
    "Dieu dit à Jonas d'aller à Ninive.",
    "Jonas s'enfuit par la mer et une tempête se lève.",
    "Jonas est avalé par un grand poisson pendant trois jours.",
    "Il prie Dieu, puis est rejeté sur le rivage et obéit."
  ],
  "key_verse": "La délivrance vient du Seigneur.",
  "vocab": [
    { "word": "prophète", "hint": "Quelqu'un qui parle pour Dieu." },
    { "word": "Ninive", "hint": "Grande ville ancienne." }
  ],
  "quiz": [
    { "q": "Pourquoi Jonas a-t-il fui ?", "choices": ["Par peur", "Par joie"], "answer": 0 }
  ],
  "mini_games": ["order_events"],
  "assets": ["jonas_1.png", "jonas_2.png", "jonas_3.png", "jonas_4.png"]
}
```

2. `src/phaser/scenes/OrderEventsScene.ts`
   (implémente drag & drop, vérif de l’ordre, émet un event “lesson\:completed” si OK)

```ts
import Phaser from "phaser";

export default class OrderEventsScene extends Phaser.Scene {
  private slots!: Phaser.GameObjects.Zone[];
  private cards!: Phaser.GameObjects.Container[];
  private correctOrder = ["1","2","3","4"];

  constructor() { super("OrderEvents"); }

  preload() {
    this.load.image("bg", "/assets/images/bg.jpg");
    this.load.image("card1", "/assets/images/jonas_1.png");
    this.load.image("card2", "/assets/images/jonas_2.png");
    this.load.image("card3", "/assets/images/jonas_3.png");
    this.load.image("card4", "/assets/images/jonas_4.png");
  }

  create() {
    const { width, height } = this.scale;
    this.add.image(width/2, height/2, "bg").setAlpha(0.25).setDisplaySize(width, height);

    this.slots = [0,1,2,3].map((i) => {
      const x = 200 + i * 220;
      const z = this.add.zone(x, 280, 180, 240).setRectangleDropZone(180, 240);
      this.add.rectangle(x, 280, 180, 240).setStrokeStyle(2);
      (z as any).index = i;
      return z;
    });

    const keys = ["card1","card2","card3","card4"].sort(() => Math.random() - 0.5);
    this.cards = keys.map((key, i) => {
      const c = this.add.container(200 + i*220, 520);
      const img = this.add.image(0, 0, key).setDisplaySize(180, 240);
      const label = this.add.text(0, 150, key.replace("card",""), { fontSize: "24px" }).setOrigin(0.5);
      c.add([img, label]);
      c.setSize(180, 240);
      c.setInteractive({ draggable: true, useHandCursor: true });
      this.input.setDraggable(c);
      return c;
    });

    this.input.on("drag", (_p: any, obj: any, x: number, y: number) => obj.setPosition(x, y));
    this.input.on("drop", (_p: any, obj: any, zone: any) => {
      obj.x = zone.x; obj.y = zone.y; (obj as any).slotIndex = zone.index; this.checkWin();
    });

    this.add.text(width/2, 40, "Remets les scènes dans l'ordre", { fontSize: "28px" }).setOrigin(0.5);
  }

  private checkWin() {
    const placed = this.cards.filter(c => (c as any).slotIndex !== undefined)
      .sort((a: any, b: any) => a.slotIndex - b.slotIndex);

    if (placed.length !== 4) return;

    const order = placed.map(c => (c.list[1] as Phaser.GameObjects.Text).text); // "1..4"
    const ok = order.every((v, i) => v === this.correctOrder[i]);

    const msg = ok ? "Bravo ! Jonas a obéi à Dieu." : "Regarde bien l'histoire, essaie encore.";
    const t = this.add.text(640, 80, msg, { fontSize: "24px" }).setOrigin(0.5).setDepth(5);

    if (ok) {
      this.time.delayedCall(900, () => {
        this.events.emit("lesson:completed", { badge: "Ami des Prophètes" });
      });
    } else {
      this.time.delayedCall(1200, () => t.destroy());
    }
  }
}
```

3. `src/components/PhaserGame.tsx`
   (monte la scène et propage l’event vers React)

```tsx
import { useEffect, useRef } from "react";
import Phaser from "phaser";
import OrderEventsScene from "../phaser/scenes/OrderEventsScene";

type Props = { onComplete?: (data: { badge: string }) => void };

export default function PhaserGame({ onComplete }: Props) {
  const gameRef = useRef<Phaser.Game | null>(null);
  useEffect(() => {
    const config: Phaser.Types.Core.GameConfig = {
      type: Phaser.AUTO,
      width: 1280,
      height: 720,
      parent: "phaser-root",
      backgroundColor: "#f7f7f7",
      scene: [OrderEventsScene],
    };
    const game = new Phaser.Game(config);
    gameRef.current = game;

    const onBoot = () => {
      const scene = game.scene.getScene("OrderEvents") as OrderEventsScene;
      scene.events.on("lesson:completed", (payload) => onComplete?.(payload));
    };

    game.events.on("ready", onBoot);
    // @ts-ignore
    game.events.emit("ready");

    return () => { game.destroy(true); gameRef.current = null; };
  }, [onComplete]);

  return <div id="phaser-root" className="w-full h-full" />;
}
```

4. `src/state/settingsStore.ts` (Zustand)

```ts
import { create } from "zustand";

type Settings = {
  fontScale: number; contrastHigh: boolean; audioOn: boolean; fontFamily: "default" | "opendyslexic";
  setFontScale: (v: number) => void; toggleContrast: () => void; toggleAudio: () => void; setFont: (f: Settings["fontFamily"]) => void;
};
export const useSettings = create<Settings>((set) => ({
  fontScale: 1, contrastHigh: false, audioOn: true, fontFamily: "default",
  setFontScale: (v) => set({ fontScale: Math.max(0.8, Math.min(1.6, v)) }),
  toggleContrast: () => set(s => ({ contrastHigh: !s.contrastHigh })),
  toggleAudio: () => set(s => ({ audioOn: !s.audioOn })),
  setFont: (f) => set({ fontFamily: f })
}));
```

5. `src/state/progressStore.ts`

```ts
import { create } from "zustand";

type Progress = { completed: Record<string, { badge?: string; date: string }>; markDone: (id: string, badge?: string) => void; reset: () => void; };
export const useProgress = create<Progress>((set) => ({
  completed: JSON.parse(localStorage.getItem("progress") || "{}"),
  markDone: (id, badge) => set((s) => {
    const next = { ...s.completed, [id]: { badge, date: new Date().toISOString() } };
    localStorage.setItem("progress", JSON.stringify(next)); return { completed: next };
  }),
  reset: () => set(() => { localStorage.removeItem("progress"); return { completed: {} }; })
}));
```

6. `src/pages/Lesson.tsx` (lit le JSON, affiche lecture guidée + lance Phaser)

```tsx
import { useEffect, useState } from "react";
import PhaserGame from "../components/PhaserGame";
import { useProgress } from "../state/progressStore";

export default function Lesson() {
  const [data, setData] = useState<any>(null);
  const { markDone } = useProgress();

  useEffect(() => {
    fetch("/src/content/jonas_01.json").then(r => r.json()).then(setData);
  }, []);

  if (!data) return <div className="p-6">Chargement…</div>;

  return (
    <div className="p-6 space-y-6">
      <h1 className="text-3xl font-bold">{data.title}</h1>
      <section className="space-y-2">
        {data.reading.map((s: string, i: number) => (
          <p key={i} className="text-lg leading-relaxed">{s}</p>
        ))}
        <div className="p-4 rounded bg-gray-100"><em>Verset clé : “{data.key_verse}”</em></div>
      </section>

      <div className="h-[560px] rounded border overflow-hidden">
        <PhaserGame onComplete={({ badge }) => {
          markDone(data.id, badge);
          alert(`Bravo ! Badge obtenu : ${badge}`);
        }}/>
      </div>
    </div>
  );
}
```

7. **Tailwind & styles** : index.css avec classes utilitaires, thème contraste élevé via `contrast-high` sur `<html>` (toggle dans Settings).

8. **PWA** : `vite.config.ts` configure `vite-plugin-pwa` (manifest basique), `public/manifest.webmanifest` et icônes.

**SCRIPTS NPM ATTENDUS**

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .ts,.tsx",
    "format": "prettier --write ."
  }
}
```

**CONTRAINTES LÉGALES (commentaires dans README)**

* RGPD-K : pas de profilage enfant, pas de pub ciblée, progression stockée en localStorage.
* Textes bibliques : utiliser domaine public ou obtenir autorisation de l’éditeur avant intégration.
* Iconographie : respectueuse, pas de caricature d’éléments sacrés.

**CRITÈRES D’ACCEPTATION**

* `pnpm i && pnpm dev` lance l’app, home visible, carte “Jonas” ouvre la page leçon + mini-jeu jouable.
* Victoire mini-jeu → badge + écriture dans `localStorage`.
* Réglages (font + contraste + audio) visibles et persistants (Zustand state persistant ou simple localStorage).
* Build PWA passe, app installable.

**BONUS (si temps)**

* Composant “Quiz” (1 QCM) après la victoire.
* Bouton “Imprimer le journal”.

— Fin du prompt —

---
